From 98551bdfd4759008b3ca5df1b98859295cb92023 Mon Sep 17 00:00:00 2001
From: Kobus Goosen <kgoosen@videologyinc.com>
Date: Tue, 20 Sep 2022 17:00:21 +0200
Subject: [PATCH] crosslink_ov5640

---
 drivers/media/i2c/ov5640.c                    | 140 +++++++++++++-----
 .../media/platform/mxc/capture/mxc_mipi_csi.c |  15 ++
 .../platform/mxc/capture/ov5640_mipi_v2.c     |  67 +++++----
 drivers/staging/media/imx/imx8-isi-cap.c      |   6 +-
 .../staging/media/imx/imx8-mipi-csi2-sam.c    |  11 +-
 5 files changed, 169 insertions(+), 70 deletions(-)

diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 1b2b947d7b3a..d074aeb7b4a0 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -641,7 +641,7 @@ static int ov5640_init_slave_id(struct ov5640_dev *sensor)
 	ret = i2c_transfer(client->adapter, &msg, 1);
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: failed with %d\n", __func__, ret);
-		return ret;
+//HH		return ret;
 	}
 
 	return 0;
@@ -667,7 +667,7 @@ static int ov5640_write_reg(struct ov5640_dev *sensor, u16 reg, u8 val)
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
 			__func__, reg, val);
-		return ret;
+//HH		return ret;
 	}
 
 	return 0;
@@ -697,7 +697,7 @@ static int ov5640_read_reg(struct ov5640_dev *sensor, u16 reg, u8 *val)
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: error: reg=%x\n",
 			__func__, reg);
-		return ret;
+//HH		return ret;
 	}
 
 	*val = buf[0];
@@ -710,11 +710,11 @@ static int ov5640_read_reg16(struct ov5640_dev *sensor, u16 reg, u16 *val)
 	int ret;
 
 	ret = ov5640_read_reg(sensor, reg, &hi);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 	ret = ov5640_read_reg(sensor, reg + 1, &lo);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	*val = ((u16)hi << 8) | (u16)lo;
 	return 0;
@@ -725,8 +725,8 @@ static int ov5640_write_reg16(struct ov5640_dev *sensor, u16 reg, u16 val)
 	int ret;
 
 	ret = ov5640_write_reg(sensor, reg, val >> 8);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	return ov5640_write_reg(sensor, reg + 1, val & 0xff);
 }
@@ -738,8 +738,8 @@ static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
 	int ret;
 
 	ret = ov5640_read_reg(sensor, reg, &readval);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	readval &= ~mask;
 	val &= mask;
@@ -932,6 +932,7 @@ static unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,
 	*sysdiv = best_sysdiv;
 	*pll_prediv = OV5640_PLL_PREDIV;
 	*pll_mult = best_mult;
+printk("%s - BEST FREQ=%lu [%lu %lu %lu]\n", __func__, best, best_sysdiv, OV5640_PLL_PREDIV, best_mult);
 
 	return best;
 }
@@ -961,13 +962,20 @@ static int ov5640_check_valid_mode(struct ov5640_dev *sensor,
 			ret = -EINVAL;
 		break;
 	case OV5640_MODE_1080P_1920_1080:
+	printk("%s case OV5640_MODE_1080P_1920_1080 \n", __func__);
 		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		printk("%s : V4L2_MBUS_CSI2_DPHY\n", __func__);
 			if ((rate != OV5640_15_FPS) &&
-			    (rate != OV5640_30_FPS))
+			    (rate != OV5640_30_FPS)){
+		printk("%s : ((rate != OV5640_15_FPS) && (rate != OV5640_30_FPS))\n", __func__);
 				ret = -EINVAL;
+				}
 		 } else {
-			if ((rate != OV5640_15_FPS))
+		printk("%s : NOT V4L2_MBUS_CSI2_DPHY\n", __func__);
+			if ((rate != OV5640_15_FPS)){
+		printk("%s : rate != OV5640_15_FPS\n", __func__);
 				ret = -EINVAL;
+				}
 		 }
 		break;
 	case OV5640_MODE_QSXGA_2592_1944:
@@ -2229,16 +2237,24 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 	 */
 	if (sensor->power_count == !on) {
 		ret = ov5640_set_power(sensor, !!on);
-		if (ret)
+ret=0;
+		if (ret){
+		printk(">>> %s: ov5640_set_power failed!\n", __func__);
 			goto out;
+			}
 	}
-
 	/* Update the power count. */
 	sensor->power_count += on ? 1 : -1;
 	WARN_ON(sensor->power_count < 0);
 out:
 	mutex_unlock(&sensor->lock);
 
+if (ret){
+	printk(">>> %s: ov5640_set_power failed!\n", __func__);
+	}
+	 else printk(">>> %s: ov5640_set_power ret=0\n", __func__);
+
+
 	if (on && !ret && sensor->power_count == 1) {
 		/* restore controls */
 		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
@@ -2368,8 +2384,10 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 
 	ret = ov5640_try_fmt_internal(sd, mbus_fmt,
 				      sensor->current_fr, &new_mode);
-	if (ret)
+	if (ret){
+	printk("%s - ov5640_try_fmt_internal ERROR \n", __func__);
 		goto out;
+		}
 
 	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
@@ -2390,6 +2408,13 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 
 	if (sensor->pending_mode_change || sensor->pending_fmt_change)
 		sensor->fmt = *mbus_fmt;
+
+printk("%s <<- end \n", __func__);
+printk("%s: sensor->ep.bus_type =%d\n", __func__, sensor->ep.bus_type);
+printk("%s: sensor->ep.bus      =%x\n", __func__, sensor->ep.bus);
+printk("%s: sensor->fmt->height =%d\n", __func__, mbus_fmt->height);
+printk("%s: sensor->fmt->width  =%d\n", __func__, mbus_fmt->width);
+
 out:
 	mutex_unlock(&sensor->lock);
 	return ret;
@@ -2875,9 +2900,11 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	v4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);
 
 	sensor->sd.ctrl_handler = hdl;
+printk("%s - ok\n", __func__);
 	return 0;
 
 free_ctrls:
+printk("%s - error hdl->error returned from v4l2_ctrl_new_std_menu(..)\n", __func__);
 	v4l2_ctrl_handler_free(hdl);
 	return ret;
 }
@@ -3010,6 +3037,7 @@ static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
 		return -EINVAL;
 
 	code->code = ov5640_formats[code->index].code;
+	printk("%s - code->code = 0x%4x\n", __func__, code->code);
 	return 0;
 }
 
@@ -3019,43 +3047,62 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 	struct i2c_client *client = sensor->i2c_client;
 	int ret = 0;
 
+	printk(">>>> %s - start: sensor->ep.bus_type=%d \n", __func__, sensor->ep.bus_type);
+
 	mutex_lock(&sensor->lock);
 
 	if (sensor->streaming == !enable) {
+		printk("%s sensor->streaming= %d\n", __func__, sensor->streaming);
 		ret = ov5640_check_valid_mode(sensor,
 					      sensor->current_mode,
 					      sensor->current_fr);
 		if (ret) {
-			dev_err(&client->dev, "Not support WxH@fps=%dx%d@%d\n",
+			printk("%s - %s - Not support WxH@fps=%dx%d@%d\n", &client->dev, __func__,
 				sensor->current_mode->hact,
 				sensor->current_mode->vact,
 				ov5640_framerates[sensor->current_fr]);
 			goto out;
-		}
+		}else 	printk("%s - Support WxH@fps=%dx%d@%d\n", __func__,
+				sensor->current_mode->hact,
+				sensor->current_mode->vact,
+				ov5640_framerates[sensor->current_fr]);
 
 		if (enable && sensor->pending_mode_change) {
 			ret = ov5640_set_mode(sensor);
-			if (ret)
-				goto out;
+			if (ret){
+			printk("%s - ov5640_set_mode failed\n", __func__);
+//				goto out;
+				} else
+			printk("%s - ov5640_set_mode OK\n", __func__);
 		}
 
 		if (enable && sensor->pending_fmt_change) {
 			ret = ov5640_set_framefmt(sensor, &sensor->fmt);
-			if (ret)
-				goto out;
-			sensor->pending_fmt_change = false;
+			if (ret){
+			printk("%s - ov5640_set_framefmt failed\n", __func__);
+//				goto out;
 		}
+			sensor->pending_fmt_change = false;
+		}else 			printk("%s - ov5640_set_framefmt OK\n", __func__);
 
-		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+
+		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY){
 			ret = ov5640_set_stream_mipi(sensor, enable);
-		else
+		printk("%s: ov5640_set_stream_mipi(sensor, enable)=%d\n", __func__,ret);
+		} else {
 			ret = ov5640_set_stream_dvp(sensor, enable);
+		printk("%s: ov5640_set_stream_dvp(sensor, enable)=%d\n", __func__,ret);
+			}
 
-		if (!ret)
+		if (!ret){
 			sensor->streaming = enable;
-	}
+			printk("<<<<< %s sensor->streaming (mipi/dvp)= ENABLED\n", __func__);
+			}
+	} else 	printk("<<<<< %s sensor->streaming (mipi/dvp)= NOT ENABLED\n", __func__);
+
 out:
 	mutex_unlock(&sensor->lock);
+	printk("<<<< %s sensor->streaming=%d\n", __func__, sensor->streaming);
 	return ret;
 }
 
@@ -3101,9 +3148,10 @@ static int ov5640_get_regulators(struct ov5640_dev *sensor)
 {
 	int i;
 
-	for (i = 0; i < OV5640_NUM_SUPPLIES; i++)
+	for (i = 0; i < OV5640_NUM_SUPPLIES; i++){
 		sensor->supplies[i].supply = ov5640_supply_name[i];
-
+		printk("%s - %s\n", __func__, ov5640_supply_name[i]);
+}
 	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
 				       OV5640_NUM_SUPPLIES,
 				       sensor->supplies);
@@ -3146,6 +3194,9 @@ static int ov5640_probe(struct i2c_client *client)
 	u32 rotation;
 	int ret;
 
+printk("-->%s OV5640 Probe start\n",__func__);
+//dev_info(dev, "%s - Start\n", __func__);
+
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
 		return -ENOMEM;
@@ -3204,6 +3255,8 @@ static int ov5640_probe(struct i2c_client *client)
 		return ret;
 	}
 
+	printk("%s: sensor->ep.bus_type=%d\n", __func__, sensor->ep.bus_type);
+
 	if (sensor->ep.bus_type != V4L2_MBUS_PARALLEL &&
 	    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY &&
 	    sensor->ep.bus_type != V4L2_MBUS_BT656) {
@@ -3214,8 +3267,8 @@ static int ov5640_probe(struct i2c_client *client)
 	/* get system clock (xclk) */
 	sensor->xclk = devm_clk_get(dev, "xclk");
 	if (IS_ERR(sensor->xclk)) {
-		dev_err(dev, "failed to get xclk\n");
-		return PTR_ERR(sensor->xclk);
+		dev_err(dev, "failed to get xclk - FATAL!\n");
+//		return PTR_ERR(sensor->xclk);
 	}
 
 	sensor->xclk_freq = clk_get_rate(sensor->xclk);
@@ -3223,20 +3276,24 @@ static int ov5640_probe(struct i2c_client *client)
 	    sensor->xclk_freq > OV5640_XCLK_MAX) {
 		dev_err(dev, "xclk frequency out of range: %d Hz\n",
 			sensor->xclk_freq);
-		return -EINVAL;
+//		return -EINVAL;
 	}
 
 	/* request optional power down pin */
 	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
 						    GPIOD_OUT_HIGH);
-	if (IS_ERR(sensor->pwdn_gpio))
-		return PTR_ERR(sensor->pwdn_gpio);
+	if (IS_ERR(sensor->pwdn_gpio)){
+		printk("%s - sensor->pwnd_gpio not found\n", __func__);
+//		return PTR_ERR(sensor->pwdn_gpio);
+	}
 
 	/* request optional reset pin */
 	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
 						     GPIOD_OUT_HIGH);
-	if (IS_ERR(sensor->reset_gpio))
-		return PTR_ERR(sensor->reset_gpio);
+	if (IS_ERR(sensor->reset_gpio)){
+		printk("%s - sensor->reset_gpio not found\n", __func__);
+//		return PTR_ERR(sensor->reset_gpio);
+	}
 
 	v4l2_i2c_subdev_init(&sensor->sd, client, &ov5640_subdev_ops);
 
@@ -3255,8 +3312,12 @@ static int ov5640_probe(struct i2c_client *client)
 	mutex_init(&sensor->lock);
 
 	ret = ov5640_check_chip_id(sensor);
-	if (ret)
-		goto entity_cleanup;
+	if (ret){
+		dev_info(dev, "%s OV5640 chip_id NOK - not present, no exit\n",__func__);
+//		goto entity_cleanup;
+	} else {
+		dev_info(dev, "%s OV5640 chip_id OK - present\n",__func__);
+	}
 
 	ret = ov5640_init_controls(sensor);
 	if (ret)
@@ -3266,11 +3327,14 @@ static int ov5640_probe(struct i2c_client *client)
 	if (ret)
 		goto free_ctrls;
 
+printk("<--%s OV5640 Probe end successful, return\n",__func__);
 	return 0;
 
 free_ctrls:
+printk("---%s OV5640 ERR free_ctrls\n",__func__);
 	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
 entity_cleanup:
+printk("---%s OV5640 ERR entity_cleanup\n",__func__);
 	media_entity_cleanup(&sensor->sd.entity);
 	mutex_destroy(&sensor->lock);
 	return ret;
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index 069a0b9bb961..e48f04712b15 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -887,6 +887,8 @@ static irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)
 	unsigned long flags;
 	u32 status;
 
+dev_info(&state->pdev->dev, "%s -> IRQ start\n", __func__);
+
 	status = mipi_csis_read(state, MIPI_CSIS_INTSRC);
 
 	spin_lock_irqsave(&state->slock, flags);
@@ -947,12 +949,16 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 {
 	struct device_node *node = pdev->dev.of_node;
 
+dev_info(&pdev->dev, "%s: parse start\n", __func__);
+
 	if (of_property_read_u32(node, "clock-frequency",
 				 &state->clk_frequency))
 		state->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;
 	if (of_property_read_u32(node, "bus-width",
 				 &state->max_num_lanes))
 		return -EINVAL;
+dev_info(&pdev->dev, "%s: state->clk_frequency = %n\n", __func__, &state->clk_frequency);
+dev_info(&pdev->dev, "%s: state->max_num_lanes = %n\n", __func__, &state->max_num_lanes);
 
 	node = of_graph_get_next_endpoint(node, NULL);
 	if (!node) {
@@ -961,6 +967,8 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
+dev_info(&pdev->dev, "%s: pdev->dev.of_node->full_name = %s\n", __func__, pdev->dev.of_node->full_name);
+
 	/* Get MIPI CSI-2 bus configration from the endpoint node. */
 	of_property_read_u32(node, "csis-hs-settle",
 					&state->hs_settle);
@@ -973,6 +981,7 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 	of_property_read_u32(node, "data-lanes",
 					&state->num_lanes);
 	of_node_put(node);
+dev_info(&pdev->dev, "%s: parse end\n", __func__);
 
 	return 0;
 }
@@ -1046,6 +1055,8 @@ static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
 	struct csi_state *state = platform_get_drvdata(pdev);
 	int ret = 0;
 
+dev_info(&pdev->dev, "%s -> start\n", __func__);
+
 	v4l2_subdev_init(mipi_sd, ops);
 	mipi_sd->owner = THIS_MODULE;
 	snprintf(mipi_sd->name, sizeof(mipi_sd->name), "%s.%d",
@@ -1064,6 +1075,7 @@ static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
 	ret = v4l2_async_register_subdev(mipi_sd);
 	if (ret < 0)
 		dev_err(&pdev->dev, "%s--Async register faialed, ret=%d\n", __func__, ret);
+dev_info(&pdev->dev, "%s <- end\n", __func__);
 
 	return ret;
 }
@@ -1078,6 +1090,8 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	mipi_csis_phy_reset_t phy_reset_fn;
 	int ret = -ENOMEM;
 
+dev_info(dev, "%s -> start\n", __func__);
+
 	state = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);
 	if (!state)
 		return -ENOMEM;
@@ -1176,6 +1190,7 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	v4l2_async_unregister_subdev(&state->mipi_sd);
 e_clkdis:
 	mipi_csis_clk_disable(state);
+dev_info(dev, "%s <- end\n", __func__);
 	return ret;
 }
 
diff --git a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
index eac8b12360dc..dfff3e209bb4 100644
--- a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
+++ b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
@@ -1702,6 +1702,8 @@ static int ov5640_probe(struct i2c_client *client,
 	u8 chip_id_high, chip_id_low;
 	struct ov5640 *sensor;
 
+dev_info(dev,"%s - start\n", __func__);
+
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
 		return -ENOMEM;
@@ -1712,31 +1714,31 @@ static int ov5640_probe(struct i2c_client *client,
 		dev_warn(dev, "No pin available\n");
 
 	/* request power down pin */
-	sensor->pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
-	if (!gpio_is_valid(sensor->pwn_gpio))
-		dev_warn(dev, "No sensor pwdn pin available");
-	else {
-		retval = devm_gpio_request_one(dev, sensor->pwn_gpio,
-				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_pwdn");
-		if (retval < 0) {
-			dev_warn(dev, "Failed to set power pin\n");
-			dev_warn(dev, "retval=%d\n", retval);
-			return retval;
-		}
-	}
+//	sensor->pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+//	if (!gpio_is_valid(sensor->pwn_gpio))
+//		dev_warn(dev, "No sensor pwdn pin available");
+//	else {
+//		retval = devm_gpio_request_one(dev, sensor->pwn_gpio,
+//				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_pwdn");
+//		if (retval < 0) {
+//			dev_warn(dev, "Failed to set power pin\n");
+//			dev_warn(dev, "retval=%d\n", retval);
+//			return retval;
+//		}
+//	}
 
 	/* request reset pin */
-	sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
-	if (!gpio_is_valid(sensor->rst_gpio))
-		dev_warn(dev, "No sensor reset pin available");
-	else {
-		retval = devm_gpio_request_one(dev, sensor->rst_gpio,
-				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_reset");
-		if (retval < 0) {
-			dev_warn(dev, "Failed to set reset pin\n");
-			return retval;
-		}
-	}
+//	sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+//	if (!gpio_is_valid(sensor->rst_gpio))
+//		dev_warn(dev, "No sensor reset pin available");
+//	else {
+//		retval = devm_gpio_request_one(dev, sensor->rst_gpio,
+//				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_reset");
+//		if (retval < 0) {
+//			dev_warn(dev, "Failed to set reset pin\n");
+//			return retval;
+//		}
+//	}
 
 
 	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
@@ -1744,15 +1746,15 @@ static int ov5640_probe(struct i2c_client *client,
 		/* assuming clock enabled by default */
 		sensor->sensor_clk = NULL;
 		dev_err(dev, "clock-frequency missing or invalid\n");
-		return PTR_ERR(sensor->sensor_clk);
-	}
+//		return PTR_ERR(sensor->sensor_clk);
+	} else {dev_info(dev, "%s - csi_mclk clock-frequency defined\n", __func__);}
 
 	retval = of_property_read_u32(dev->of_node, "mclk",
 					&(sensor->mclk));
 	if (retval) {
 		dev_err(dev, "mclk missing or invalid\n");
 		return retval;
-	}
+	} else {dev_info(dev, "%s - mclk found\n", __func__);}
 
 	if (sensor->mclk == OV5640_XCLK_20MHZ)
 		ov5640_adjust_setting_20mhz();
@@ -1762,7 +1764,7 @@ static int ov5640_probe(struct i2c_client *client,
 	if (retval) {
 		dev_err(dev, "mclk_source missing or invalid\n");
 		return retval;
-	}
+	} else {dev_info(dev, "%s - mclk found\n", __func__);}
 
 	retval = of_property_read_u32(dev->of_node, "csi_id",
 					&(sensor->csi));
@@ -1793,8 +1795,10 @@ static int ov5640_probe(struct i2c_client *client,
 		retval = ov5640_update_slave_id(sensor);
 	}
 	mutex_unlock(&ov5640_mutex);
+
 	if (retval < 0) {
 		clk_disable_unprepare(sensor->sensor_clk);
+	printk("%s clk_disable_unprepare FAILED!, exit driver.\n", __func__);
 		return -ENODEV;
 	}
 
@@ -1806,6 +1810,7 @@ static int ov5640_probe(struct i2c_client *client,
 		clk_disable_unprepare(sensor->sensor_clk);
 		return -ENODEV;
 	}
+
 	retval = ov5640_read_reg(sensor, OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x40) {
 		dev_warn(dev, "Camera is not found\n");
@@ -1821,18 +1826,24 @@ static int ov5640_probe(struct i2c_client *client,
 		clk_disable_unprepare(sensor->sensor_clk);
 		dev_warn(dev, "Camera init failed\n");
 		ov5640_power_down(sensor, 1);
+	printk("%s init_device FAILED!, exit driver.\n", __func__);
 		return retval;
 	}
 
 	v4l2_i2c_subdev_init(&sensor->subdev, client, &ov5640_subdev_ops);
+dev_info(dev, "%s: v4l2_i2c_subdev_init done\n", __func__);
 
 	sensor->subdev.grp_id = 678;
 	retval = v4l2_async_register_subdev(&sensor->subdev);
-	if (retval < 0)
+	if (retval < 0){
 		dev_err(&client->dev, "Async register failed, ret=%d\n",
 			retval);
+			} else {
+		dev_info(dev, "%s: v4l2_async_register_subdev done\n", __func__);
+			};
 
 	OV5640_stream_off(sensor);
+
 	dev_info(dev, "Camera is found\n");
 	return retval;
 }
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index 57ec7b4354b1..93f90b62e974 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -122,9 +122,9 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 	}, {
-		.name		= "YUV32 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV32,
-		.depth		= { 32 },
+		.name		= "YUV 4:2:2",
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.depth		= { 16 },
 		.memplanes	= 1,
 		.colplanes	= 1,
 	}
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 928c64d3be49..fec3e295ebd1 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -550,6 +550,7 @@ static void dump_csis_regs(struct csi_state *state, const char *label)
 	for (i = 0; i < ARRAY_SIZE(registers); i++) {
 		u32 cfg = mipi_csis_read(state, registers[i].offset);
 		v4l2_dbg(2, debug, &state->sd, "%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
+		printk("%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
 	}
 }
 
@@ -663,8 +664,10 @@ static void mipi_csis_enable_interrupts(struct csi_state *state, bool on)
 	val = mipi_csis_read(state, MIPI_CSIS_INTMSK);
 	if (on)
 		val |= 0x0FFFFF1F;
-	else
+	else{
 		val &= ~0x0FFFFF1F;
+printk("FRAME_COUNT= %u\n", mipi_csis_read(state, MIPI_CSIS_FRAME_COUNTER_CH0));
+		}
 	mipi_csis_write(state, MIPI_CSIS_INTMSK, val);
 }
 
@@ -1056,6 +1059,9 @@ static void mipi_csis_log_counters(struct csi_state *state, bool non_errors)
 			v4l2_info(&state->sd, "%s events: %d\n",
 				  state->events[i].name,
 				  state->events[i].counter);
+		printk("%s events: %d\n",
+				  state->events[i].name,
+				  state->events[i].counter);
 	}
 	spin_unlock_irqrestore(&state->slock, flags);
 }
@@ -1095,6 +1101,7 @@ static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
 
 	v4l2_dbg(1, debug, mipi_sd, "%s: %d, state: 0x%x\n",
 		 __func__, enable, state->flags);
+	printk("%s: %d, state: 0x%x\n", __func__, enable, state->flags);
 
 	if (enable) {
 		pm_runtime_get_sync(state->dev);
@@ -1323,6 +1330,8 @@ static int csis_s_fmt(struct v4l2_subdev *sd, struct csi_sam_format *fmt)
 	if (csis_format == NULL)
 		return -EINVAL;
 
+printk("%s - csis_format: .code=%d, .fmt_reg=%d, .data_alignment=%d\n", __func__, csis_format->code, csis_format->fmt_reg, csis_format->data_alignment);
+
 	state->csis_fmt = csis_format;
 	state->format.width = fmt->width;
 	state->format.height = fmt->height;
-- 
2.37.3

