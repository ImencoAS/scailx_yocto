From 4093b40a8688b867f9721b77cf9dfbc86c075f60 Mon Sep 17 00:00:00 2001
From: test <test@videology.nl>
Date: Mon, 4 Apr 2022 14:55:16 +0200
Subject: [PATCH] all changes

---
 drivers/media/i2c/ov5640.c                    |  325 ++++-
 .../media/platform/imx8/mxc-mipi-csi2_yav.c   |    3 +-
 .../media/platform/mxc/capture/mxc_mipi_csi.c |   15 +
 .../platform/mxc/capture/ov5640_mipi_v2.c     |   67 +-
 drivers/media/v4l2-core/v4l2-fwnode.c         |   87 +-
 drivers/media/v4l2-core/v4l2-ioctl.c          |    1 +
 drivers/mxc/mipi/mxc_mipi_csi2.c              |    2 +
 drivers/staging/media/imx/imx8-isi-cap.c      |   27 +-
 drivers/staging/media/imx/imx8-isi-core.c     |    7 +
 drivers/staging/media/imx/imx8-isi-m2m.c      |    2 +
 drivers/staging/media/imx/imx8-media-dev.c    |   18 +-
 .../staging/media/imx/imx8-mipi-csi2-sam.c    |   27 +-
 drivers/staging/media/imx/imx8-mipi-csi2.c    |    2 +
 drivers/staging/media/imx/imx8-parallel-csi.c |    2 +
 14 files changed, 925 insertions(+), 1415 deletions(-)

diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index 159e5181ed9c..b14ac4bd9ca6 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -145,6 +145,76 @@ static const struct ov5640_pixfmt ov5640_formats[] = {
 	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_COLORSPACE_SRGB, },
 };
 
+// #####################################################################	
+
+static const u16 ov5640_sensor_regs[] = {
+OV5640_REG_SYS_RESET02,
+OV5640_REG_SYS_CLOCK_ENABLE02,
+OV5640_REG_SYS_CTRL0,
+OV5640_REG_CHIP_ID,
+OV5640_REG_IO_MIPI_CTRL00,
+OV5640_REG_PAD_OUTPUT_ENABLE01,
+OV5640_REG_PAD_OUTPUT_ENABLE02,
+OV5640_REG_PAD_OUTPUT00,
+OV5640_REG_SYSTEM_CONTROL1,
+OV5640_REG_SC_PLL_CTRL0,
+OV5640_REG_SC_PLL_CTRL1,
+OV5640_REG_SC_PLL_CTRL2,
+OV5640_REG_SC_PLL_CTRL3,
+OV5640_REG_SLAVE_ID,
+OV5640_REG_SCCB_SYS_CTRL1,
+OV5640_REG_SYS_ROOT_DIVIDER,
+OV5640_REG_AWB_R_GAIN,
+OV5640_REG_AWB_G_GAIN,
+OV5640_REG_AWB_B_GAIN,
+OV5640_REG_AWB_MANUAL_CTRL,
+OV5640_REG_AEC_PK_EXPOSURE_HI,
+OV5640_REG_AEC_PK_EXPOSURE_MED,
+OV5640_REG_AEC_PK_EXPOSURE_LO,
+OV5640_REG_AEC_PK_MANUAL,
+OV5640_REG_AEC_PK_REAL_GAIN,
+OV5640_REG_AEC_PK_VTS,
+OV5640_REG_TIMING_DVPHO,
+OV5640_REG_TIMING_DVPVO,
+OV5640_REG_TIMING_HTS,
+OV5640_REG_TIMING_VTS,
+OV5640_REG_TIMING_TC_REG20,
+OV5640_REG_TIMING_TC_REG21,
+OV5640_REG_AEC_CTRL00,
+OV5640_REG_AEC_B50_STEP,
+OV5640_REG_AEC_B60_STEP,
+OV5640_REG_AEC_CTRL0D,
+OV5640_REG_AEC_CTRL0E,
+OV5640_REG_AEC_CTRL0F,
+OV5640_REG_AEC_CTRL10,
+OV5640_REG_AEC_CTRL11,
+OV5640_REG_AEC_CTRL1B,
+OV5640_REG_AEC_CTRL1E,
+OV5640_REG_AEC_CTRL1F,
+OV5640_REG_HZ5060_CTRL00,
+OV5640_REG_HZ5060_CTRL01,
+OV5640_REG_SIGMADELTA_CTRL0C,
+OV5640_REG_FRAME_CTRL01,
+OV5640_REG_FORMAT_CONTROL00,
+OV5640_REG_VFIFO_HSIZE,
+OV5640_REG_VFIFO_VSIZE,
+OV5640_REG_JPG_MODE_SELECT,
+OV5640_REG_CCIR656_CTRL00,
+OV5640_REG_POLARITY_CTRL00,
+OV5640_REG_MIPI_CTRL00,
+OV5640_REG_DEBUG_MODE,
+OV5640_REG_ISP_FORMAT_MUX_CTRL,
+OV5640_REG_PRE_ISP_TEST_SET1,
+OV5640_REG_SDE_CTRL0,
+OV5640_REG_SDE_CTRL1,
+OV5640_REG_SDE_CTRL3,
+OV5640_REG_SDE_CTRL4,
+OV5640_REG_SDE_CTRL5,
+OV5640_REG_AVG_READOUT
+};
+
+// #####################################################################	
+
 /*
  * FIXME: remove this when a subdev API becomes available
  * to set the MIPI CSI-2 virtual channel.
@@ -569,7 +639,7 @@ static const struct ov5640_mode_info ov5640_mode_init_data = {
 	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
 	OV5640_30_FPS,
 };
-
+	 
 static const struct ov5640_mode_info
 ov5640_mode_data[OV5640_NUM_MODES] = {
 	{OV5640_MODE_QCIF_176_144, SUBSAMPLING,
@@ -641,7 +711,7 @@ static int ov5640_init_slave_id(struct ov5640_dev *sensor)
 	ret = i2c_transfer(client->adapter, &msg, 1);
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: failed with %d\n", __func__, ret);
-		return ret;
+//HH		return ret;
 	}
 
 	return 0;
@@ -667,7 +737,7 @@ static int ov5640_write_reg(struct ov5640_dev *sensor, u16 reg, u8 val)
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
 			__func__, reg, val);
-		return ret;
+//HH		return ret;
 	}
 
 	return 0;
@@ -697,7 +767,7 @@ static int ov5640_read_reg(struct ov5640_dev *sensor, u16 reg, u8 *val)
 	if (ret < 0) {
 		dev_err(&client->dev, "%s: error: reg=%x\n",
 			__func__, reg);
-		return ret;
+//HH		return ret;
 	}
 
 	*val = buf[0];
@@ -710,11 +780,11 @@ static int ov5640_read_reg16(struct ov5640_dev *sensor, u16 reg, u16 *val)
 	int ret;
 
 	ret = ov5640_read_reg(sensor, reg, &hi);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 	ret = ov5640_read_reg(sensor, reg + 1, &lo);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	*val = ((u16)hi << 8) | (u16)lo;
 	return 0;
@@ -725,8 +795,8 @@ static int ov5640_write_reg16(struct ov5640_dev *sensor, u16 reg, u16 val)
 	int ret;
 
 	ret = ov5640_write_reg(sensor, reg, val >> 8);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	return ov5640_write_reg(sensor, reg + 1, val & 0xff);
 }
@@ -738,8 +808,8 @@ static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
 	int ret;
 
 	ret = ov5640_read_reg(sensor, reg, &readval);
-	if (ret)
-		return ret;
+//	if (ret)
+//		return ret;
 
 	readval &= ~mask;
 	val &= mask;
@@ -748,6 +818,71 @@ static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
 	return ov5640_write_reg(sensor, reg, val);
 }
 
+
+// #########################################################################################
+
+static void ov5460_dump_registers(struct ov5640_dev *sensor){
+	u8 temp;
+	int ret;
+	u16 reg_addr;
+	int i;
+	
+	for (i = 0; i < ARRAY_SIZE(ov5640_sensor_regs); i++) {
+		reg_addr=ov5640_sensor_regs[i];
+		ret = ov5640_read_reg(sensor, reg_addr, &temp);
+		if(ret) continue;
+		else printk("0x%4x = 0x%02x\n", ov5640_sensor_regs[i], temp);
+	}
+	
+};
+
+static void ov5460_dump_reg_3000(struct ov5640_dev *sensor){
+	u8 temp;
+	int ret;
+	u16 reg_addr;
+	int i;
+	
+	for (i = 0x3000; i <= 0x3052; i++) {
+		reg_addr=ov5640_sensor_regs[i];
+		ret = ov5640_read_reg(sensor, reg_addr, &temp);
+		if(ret) continue;
+		else printk("0x%4x = 0x%02x\n", ov5640_sensor_regs[i], temp);
+	}
+};
+
+static void ov5460_dump_reg_3100(struct ov5640_dev *sensor){
+	u8 temp;
+	int ret;
+	u16 reg_addr;
+	int i;
+	
+	for (i = 0x3100; i <= 0x3108; i++) {
+		reg_addr=ov5640_sensor_regs[i];
+		ret = ov5640_read_reg(sensor, reg_addr, &temp);
+		if(ret) continue;
+		else printk("0x%4x = 0x%02x\n", ov5640_sensor_regs[i], temp);
+	}
+};
+
+static void ov5460_dump_reg_4800(struct ov5640_dev *sensor){
+	u8 temp;
+	int ret;
+	u16 reg_addr;
+	int i;
+	
+	for (i = 0x4800; i <= 0x4837; i++) {
+		reg_addr=ov5640_sensor_regs[i];
+		ret = ov5640_read_reg(sensor, reg_addr, &temp);
+		if(ret) continue;
+		else printk("0x%4x = 0x%02x\n", ov5640_sensor_regs[i], temp);
+	}
+};
+
+
+// #########################################################################################
+
+
+
 /*
  * After trying the various combinations, reading various
  * documentations spread around the net, and from the various
@@ -932,6 +1067,7 @@ static unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,
 	*sysdiv = best_sysdiv;
 	*pll_prediv = OV5640_PLL_PREDIV;
 	*pll_mult = best_mult;
+printk("%s - BEST FREQ=%lu [%lu %lu %lu]\n", __func__, best, best_sysdiv, OV5640_PLL_PREDIV, best_mult);
 
 	return best;
 }
@@ -961,13 +1097,20 @@ static int ov5640_check_valid_mode(struct ov5640_dev *sensor,
 			ret = -EINVAL;
 		break;
 	case OV5640_MODE_1080P_1920_1080:
+	printk("%s case OV5640_MODE_1080P_1920_1080 \n", __func__);
 		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		printk("%s : V4L2_MBUS_CSI2_DPHY\n", __func__);
 			if ((rate != OV5640_15_FPS) &&
-			    (rate != OV5640_30_FPS))
+			    (rate != OV5640_30_FPS)){
+		printk("%s : ((rate != OV5640_15_FPS) && (rate != OV5640_30_FPS))\n", __func__);
 				ret = -EINVAL;
+				}
 		 } else {
-			if ((rate != OV5640_15_FPS))
+		printk("%s : NOT V4L2_MBUS_CSI2_DPHY\n", __func__);
+			if ((rate != OV5640_15_FPS)){
+		printk("%s : rate != OV5640_15_FPS\n", __func__);
 				ret = -EINVAL;
+				}
 		 }
 		break;
 	case OV5640_MODE_QSXGA_2592_1944:
@@ -1815,6 +1958,8 @@ static int ov5640_set_mode(struct ov5640_dev *sensor)
 	unsigned long rate;
 	int ret;
 
+printk("%s - start\n", __func__);
+
 	dn_mode = mode->dn_mode;
 	orig_dn_mode = orig_mode->dn_mode;
 
@@ -1838,6 +1983,8 @@ static int ov5640_set_mode(struct ov5640_dev *sensor)
 	rate = ov5640_calc_pixel_rate(sensor) * 16;
 	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
 		rate = rate / sensor->ep.bus.mipi_csi2.num_data_lanes;
+printk("%s RATE = %lu MHz\n", __func__, rate);
+
 		ret = ov5640_set_mipi_pclk(sensor, rate);
 	} else {
 		rate = rate / sensor->ep.bus.parallel.bus_width;
@@ -1959,6 +2106,8 @@ static int ov5640_set_power_on(struct ov5640_dev *sensor)
 	struct i2c_client *client = sensor->i2c_client;
 	int ret;
 
+printk("%s - start\n", __func__);
+
 	ret = clk_prepare_enable(sensor->xclk);
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to enable clock\n",
@@ -2003,6 +2152,8 @@ static int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)
 {
 	int ret;
 
+printk("%s - start\n", __func__);
+
 	if (!on) {
 		/* Reset MIPI bus settings to their default values. */
 		ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x40);
@@ -2061,6 +2212,8 @@ static int ov5640_set_power_dvp(struct ov5640_dev *sensor, bool on)
 	u8 polarities = 0;
 	int ret;
 
+printk("%s - start\n", __func__);
+
 	if (!on) {
 		/* Reset settings to their default values. */
 		ov5640_write_reg(sensor, OV5640_REG_CCIR656_CTRL00, 0x00);
@@ -2179,6 +2332,8 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 {
 	int ret = 0;
 
+printk("%s - start\n", __func__);
+
 	if (on) {
 		ret = ov5640_set_power_on(sensor);
 		if (ret)
@@ -2212,6 +2367,8 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 {
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
 	int ret = 0;
+	
+printk(">>> %s: start\n", __func__);
 
 	mutex_lock(&sensor->lock);
 
@@ -2221,16 +2378,24 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 	 */
 	if (sensor->power_count == !on) {
 		ret = ov5640_set_power(sensor, !!on);
-		if (ret)
+ret=0;
+		if (ret){
+		printk(">>> %s: ov5640_set_power failed!\n", __func__);
 			goto out;
+			}
 	}
-
 	/* Update the power count. */
 	sensor->power_count += on ? 1 : -1;
 	WARN_ON(sensor->power_count < 0);
 out:
 	mutex_unlock(&sensor->lock);
 
+if (ret){
+	printk(">>> %s: ov5640_set_power failed!\n", __func__);
+	}
+	 else printk(">>> %s: ov5640_set_power ret=0\n", __func__);
+
+
 	if (on && !ret && sensor->power_count == 1) {
 		/* restore controls */
 		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
@@ -2285,7 +2450,9 @@ static int ov5640_get_fmt(struct v4l2_subdev *sd,
 {
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
 	struct v4l2_mbus_framefmt *fmt;
-
+	
+printk(">>>>>> %s \n",__func__);
+	
 	if (format->pad != 0)
 		return -EINVAL;
 
@@ -2301,6 +2468,9 @@ static int ov5640_get_fmt(struct v4l2_subdev *sd,
 	format->format = *fmt;
 
 	mutex_unlock(&sensor->lock);
+
+printk("<<<<<< %s \n",__func__);
+	
 	return 0;
 }
 
@@ -2313,6 +2483,8 @@ static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
 	const struct ov5640_mode_info *mode;
 	int i;
 
+printk("%s ->>> fmt->code = 0x%4x\n", __func__, fmt->code);
+
 	mode = ov5640_find_mode(sensor, fr, fmt->width, fmt->height, true);
 	if (!mode)
 		return -EINVAL;
@@ -2334,6 +2506,7 @@ static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
 	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
 	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+printk("%s <<<- ov5640_formats[%d]=0x%4x, fmt->code = 0x%4x\n", __func__, i, ov5640_formats[i].code, fmt->code);
 
 	return 0;
 }
@@ -2348,6 +2521,8 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 	struct v4l2_mbus_framefmt *fmt;
 	int ret;
 
+printk("%s ->> start \n", __func__);
+
 	if (format->pad != 0)
 		return -EINVAL;
 
@@ -2360,8 +2535,10 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 
 	ret = ov5640_try_fmt_internal(sd, mbus_fmt,
 				      sensor->current_fr, &new_mode);
-	if (ret)
+	if (ret){
+	printk("%s - ov5640_try_fmt_internal ERROR \n", __func__);
 		goto out;
+		}
 
 	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
@@ -2382,6 +2559,13 @@ static int ov5640_set_fmt(struct v4l2_subdev *sd,
 
 	if (sensor->pending_mode_change || sensor->pending_fmt_change)
 		sensor->fmt = *mbus_fmt;
+
+printk("%s <<- end \n", __func__);
+printk("%s: sensor->ep.bus_type =%d\n", __func__, sensor->ep.bus_type);
+printk("%s: sensor->ep.bus      =%x\n", __func__, sensor->ep.bus);
+printk("%s: sensor->fmt->height =%d\n", __func__, mbus_fmt->height);
+printk("%s: sensor->fmt->width  =%d\n", __func__, mbus_fmt->width);
+
 out:
 	mutex_unlock(&sensor->lock);
 	return ret;
@@ -2867,9 +3051,11 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 	v4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);
 
 	sensor->sd.ctrl_handler = hdl;
+printk("%s - ok\n", __func__);
 	return 0;
 
 free_ctrls:
+printk("%s - error hdl->error returned from v4l2_ctrl_new_std_menu(..)\n", __func__);
 	v4l2_ctrl_handler_free(hdl);
 	return ret;
 }
@@ -3002,6 +3188,7 @@ static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
 		return -EINVAL;
 
 	code->code = ov5640_formats[code->index].code;
+printk("%s - code->code = 0x%4x\n", __func__, code->code);
 	return 0;
 }
 
@@ -3011,43 +3198,75 @@ static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
 	struct i2c_client *client = sensor->i2c_client;
 	int ret = 0;
 
+printk(">>>> %s - start: sensor->ep.bus_type=%d \n", __func__, sensor->ep.bus_type);
+
 	mutex_lock(&sensor->lock);
 
 	if (sensor->streaming == !enable) {
+	printk("%s sensor->streaming= %d\n", __func__, sensor->streaming);
 		ret = ov5640_check_valid_mode(sensor,
 					      sensor->current_mode,
 					      sensor->current_fr);
 		if (ret) {
-			dev_err(&client->dev, "Not support WxH@fps=%dx%d@%d\n",
+			printk("%s - %s - Not support WxH@fps=%dx%d@%d\n", &client->dev, __func__,
 				sensor->current_mode->hact,
 				sensor->current_mode->vact,
 				ov5640_framerates[sensor->current_fr]);
 			goto out;
-		}
+		}else 	printk("%s - Support WxH@fps=%dx%d@%d\n", __func__,
+				sensor->current_mode->hact,
+				sensor->current_mode->vact,
+				ov5640_framerates[sensor->current_fr]);
 
 		if (enable && sensor->pending_mode_change) {
 			ret = ov5640_set_mode(sensor);
-			if (ret)
-				goto out;
+			if (ret){
+			printk("%s - ov5640_set_mode failed\n", __func__);
+//				goto out;
+				} else
+			printk("%s - ov5640_set_mode OK\n", __func__);
 		}
 
 		if (enable && sensor->pending_fmt_change) {
 			ret = ov5640_set_framefmt(sensor, &sensor->fmt);
-			if (ret)
-				goto out;
-			sensor->pending_fmt_change = false;
+			if (ret){
+			printk("%s - ov5640_set_framefmt failed\n", __func__);
+//				goto out;
 		}
+			sensor->pending_fmt_change = false;
+		}else 			printk("%s - ov5640_set_framefmt OK\n", __func__);
+
 
-		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY){
 			ret = ov5640_set_stream_mipi(sensor, enable);
-		else
+		printk("%s: ov5640_set_stream_mipi(sensor, enable)=%d\n", __func__,ret);
+		} else {
 			ret = ov5640_set_stream_dvp(sensor, enable);
-
-		if (!ret)
+		printk("%s: ov5640_set_stream_dvp(sensor, enable)=%d\n", __func__,ret);
+			}
+			
+		if (!ret){
 			sensor->streaming = enable;
-	}
+			printk("<<<<< %s sensor->streaming (mipi/dvp)= ENABLED\n", __func__);
+			}
+	} else 	printk("<<<<< %s sensor->streaming (mipi/dvp)= NOT ENABLED\n", __func__);
+
 out:
 	mutex_unlock(&sensor->lock);
+/*
+printk("------------------------------\n");
+ov5460_dump_registers(sensor);
+printk("------------------------------\n");
+ov5460_dump_reg_3000(sensor);
+printk("------------------------------\n");
+ov5460_dump_reg_3100(sensor);
+printk("------------------------------\n");
+ov5460_dump_reg_4800(sensor);
+printk("------------------------------\n");
+*/
+printk("<<<< %s sensor->streaming=%d\n", __func__, sensor->streaming);
+
+
 	return ret;
 }
 
@@ -3093,9 +3312,10 @@ static int ov5640_get_regulators(struct ov5640_dev *sensor)
 {
 	int i;
 
-	for (i = 0; i < OV5640_NUM_SUPPLIES; i++)
+	for (i = 0; i < OV5640_NUM_SUPPLIES; i++){
 		sensor->supplies[i].supply = ov5640_supply_name[i];
-
+		printk("%s - %s\n", __func__, ov5640_supply_name[i]);
+}
 	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
 				       OV5640_NUM_SUPPLIES,
 				       sensor->supplies);
@@ -3137,6 +3357,9 @@ static int ov5640_probe(struct i2c_client *client)
 	struct v4l2_mbus_framefmt *fmt;
 	u32 rotation;
 	int ret;
+	
+printk("-->%s OV5640 Probe start\n",__func__);	
+//dev_info(dev, "%s - Start\n", __func__);
 
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
@@ -3155,13 +3378,16 @@ static int ov5640_probe(struct i2c_client *client)
 	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
 	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
 	fmt->width = 640;
+//	fmt->width = 1920;
 	fmt->height = 480;
+//	fmt->height = 1080;
 	fmt->field = V4L2_FIELD_NONE;
 	sensor->frame_interval.numerator = 1;
 	sensor->frame_interval.denominator = ov5640_framerates[OV5640_30_FPS];
 	sensor->current_fr = OV5640_30_FPS;
 	sensor->current_mode =
 		&ov5640_mode_data[OV5640_MODE_VGA_640_480];
+//		&ov5640_mode_data[OV5640_MODE_1080P_1920_1080];
 	sensor->last_mode = sensor->current_mode;
 
 	sensor->ae_target = 52;
@@ -3195,6 +3421,8 @@ static int ov5640_probe(struct i2c_client *client)
 		dev_err(dev, "Could not parse endpoint\n");
 		return ret;
 	}
+	
+printk("%s: sensor->ep.bus_type=%d\n", __func__, sensor->ep.bus_type);
 
 	if (sensor->ep.bus_type != V4L2_MBUS_PARALLEL &&
 	    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY &&
@@ -3206,8 +3434,8 @@ static int ov5640_probe(struct i2c_client *client)
 	/* get system clock (xclk) */
 	sensor->xclk = devm_clk_get(dev, "xclk");
 	if (IS_ERR(sensor->xclk)) {
-		dev_err(dev, "failed to get xclk\n");
-		return PTR_ERR(sensor->xclk);
+		dev_err(dev, "failed to get xclk - FATAL!\n");
+//		return PTR_ERR(sensor->xclk);
 	}
 
 	sensor->xclk_freq = clk_get_rate(sensor->xclk);
@@ -3215,20 +3443,24 @@ static int ov5640_probe(struct i2c_client *client)
 	    sensor->xclk_freq > OV5640_XCLK_MAX) {
 		dev_err(dev, "xclk frequency out of range: %d Hz\n",
 			sensor->xclk_freq);
-		return -EINVAL;
+//		return -EINVAL;
 	}
 
 	/* request optional power down pin */
 	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
 						    GPIOD_OUT_HIGH);
-	if (IS_ERR(sensor->pwdn_gpio))
-		return PTR_ERR(sensor->pwdn_gpio);
-
+	if (IS_ERR(sensor->pwdn_gpio)){
+		printk("%s - sensor->pwnd_gpio not found\n", __func__);
+//		return PTR_ERR(sensor->pwdn_gpio);
+	}
+	
 	/* request optional reset pin */
 	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
 						     GPIOD_OUT_HIGH);
-	if (IS_ERR(sensor->reset_gpio))
-		return PTR_ERR(sensor->reset_gpio);
+	if (IS_ERR(sensor->reset_gpio)){
+		printk("%s - sensor->reset_gpio not found\n", __func__);
+//		return PTR_ERR(sensor->reset_gpio);
+	}
 
 	v4l2_i2c_subdev_init(&sensor->sd, client, &ov5640_subdev_ops);
 
@@ -3247,9 +3479,13 @@ static int ov5640_probe(struct i2c_client *client)
 	mutex_init(&sensor->lock);
 
 	ret = ov5640_check_chip_id(sensor);
-	if (ret)
-		goto entity_cleanup;
-
+	if (ret){
+		dev_info(dev, "%s OV5640 chip_id NOK - not present, no exit\n",__func__);
+//		goto entity_cleanup;
+	} else {
+		dev_info(dev, "%s OV5640 chip_id OK - present\n",__func__);
+	}
+	
 	ret = ov5640_init_controls(sensor);
 	if (ret)
 		goto entity_cleanup;
@@ -3258,11 +3494,14 @@ static int ov5640_probe(struct i2c_client *client)
 	if (ret)
 		goto free_ctrls;
 
+printk("<--%s OV5640 Probe end successful, return\n",__func__);	
 	return 0;
 
 free_ctrls:
+printk("---%s OV5640 ERR free_ctrls\n",__func__);	
 	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
 entity_cleanup:
+printk("---%s OV5640 ERR entity_cleanup\n",__func__);	
 	media_entity_cleanup(&sensor->sd.entity);
 	mutex_destroy(&sensor->lock);
 	return ret;
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
index 090a0c4650d5..646a1fdc5d63 100644
--- a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
@@ -563,7 +563,8 @@ static int mipi_csi2_probe(struct platform_device *pdev)
 	struct mxc_mipi_csi2_dev *csi2dev;
 	int ret = -ENOMEM;
 
-	dev_info(&pdev->dev, "%s\n", __func__);
+	dev_info(&pdev->dev, "%s -> start\n", __func__);
+
 	csi2dev = devm_kzalloc(dev, sizeof(*csi2dev), GFP_KERNEL);
 	if (!csi2dev)
 		return -ENOMEM;
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index 069a0b9bb961..e48f04712b15 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -887,6 +887,8 @@ static irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)
 	unsigned long flags;
 	u32 status;
 
+dev_info(&state->pdev->dev, "%s -> IRQ start\n", __func__);
+
 	status = mipi_csis_read(state, MIPI_CSIS_INTSRC);
 
 	spin_lock_irqsave(&state->slock, flags);
@@ -947,12 +949,16 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 {
 	struct device_node *node = pdev->dev.of_node;
 
+dev_info(&pdev->dev, "%s: parse start\n", __func__);
+
 	if (of_property_read_u32(node, "clock-frequency",
 				 &state->clk_frequency))
 		state->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;
 	if (of_property_read_u32(node, "bus-width",
 				 &state->max_num_lanes))
 		return -EINVAL;
+dev_info(&pdev->dev, "%s: state->clk_frequency = %n\n", __func__, &state->clk_frequency);
+dev_info(&pdev->dev, "%s: state->max_num_lanes = %n\n", __func__, &state->max_num_lanes);
 
 	node = of_graph_get_next_endpoint(node, NULL);
 	if (!node) {
@@ -961,6 +967,8 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 		return -EINVAL;
 	}
 
+dev_info(&pdev->dev, "%s: pdev->dev.of_node->full_name = %s\n", __func__, pdev->dev.of_node->full_name);
+
 	/* Get MIPI CSI-2 bus configration from the endpoint node. */
 	of_property_read_u32(node, "csis-hs-settle",
 					&state->hs_settle);
@@ -973,6 +981,7 @@ static int mipi_csis_parse_dt(struct platform_device *pdev,
 	of_property_read_u32(node, "data-lanes",
 					&state->num_lanes);
 	of_node_put(node);
+dev_info(&pdev->dev, "%s: parse end\n", __func__);
 
 	return 0;
 }
@@ -1046,6 +1055,8 @@ static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
 	struct csi_state *state = platform_get_drvdata(pdev);
 	int ret = 0;
 
+dev_info(&pdev->dev, "%s -> start\n", __func__);
+
 	v4l2_subdev_init(mipi_sd, ops);
 	mipi_sd->owner = THIS_MODULE;
 	snprintf(mipi_sd->name, sizeof(mipi_sd->name), "%s.%d",
@@ -1064,6 +1075,7 @@ static int mipi_csis_subdev_init(struct v4l2_subdev *mipi_sd,
 	ret = v4l2_async_register_subdev(mipi_sd);
 	if (ret < 0)
 		dev_err(&pdev->dev, "%s--Async register faialed, ret=%d\n", __func__, ret);
+dev_info(&pdev->dev, "%s <- end\n", __func__);
 
 	return ret;
 }
@@ -1078,6 +1090,8 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	mipi_csis_phy_reset_t phy_reset_fn;
 	int ret = -ENOMEM;
 
+dev_info(dev, "%s -> start\n", __func__);
+
 	state = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);
 	if (!state)
 		return -ENOMEM;
@@ -1176,6 +1190,7 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	v4l2_async_unregister_subdev(&state->mipi_sd);
 e_clkdis:
 	mipi_csis_clk_disable(state);
+dev_info(dev, "%s <- end\n", __func__);
 	return ret;
 }
 
diff --git a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
index eac8b12360dc..dfff3e209bb4 100644
--- a/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
+++ b/drivers/media/platform/mxc/capture/ov5640_mipi_v2.c
@@ -1702,6 +1702,8 @@ static int ov5640_probe(struct i2c_client *client,
 	u8 chip_id_high, chip_id_low;
 	struct ov5640 *sensor;
 
+dev_info(dev,"%s - start\n", __func__);
+
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
 		return -ENOMEM;
@@ -1712,31 +1714,31 @@ static int ov5640_probe(struct i2c_client *client,
 		dev_warn(dev, "No pin available\n");
 
 	/* request power down pin */
-	sensor->pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
-	if (!gpio_is_valid(sensor->pwn_gpio))
-		dev_warn(dev, "No sensor pwdn pin available");
-	else {
-		retval = devm_gpio_request_one(dev, sensor->pwn_gpio,
-				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_pwdn");
-		if (retval < 0) {
-			dev_warn(dev, "Failed to set power pin\n");
-			dev_warn(dev, "retval=%d\n", retval);
-			return retval;
-		}
-	}
+//	sensor->pwn_gpio = of_get_named_gpio(dev->of_node, "pwn-gpios", 0);
+//	if (!gpio_is_valid(sensor->pwn_gpio))
+//		dev_warn(dev, "No sensor pwdn pin available");
+//	else {
+//		retval = devm_gpio_request_one(dev, sensor->pwn_gpio,
+//				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_pwdn");
+//		if (retval < 0) {
+//			dev_warn(dev, "Failed to set power pin\n");
+//			dev_warn(dev, "retval=%d\n", retval);
+//			return retval;
+//		}
+//	}
 
 	/* request reset pin */
-	sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
-	if (!gpio_is_valid(sensor->rst_gpio))
-		dev_warn(dev, "No sensor reset pin available");
-	else {
-		retval = devm_gpio_request_one(dev, sensor->rst_gpio,
-				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_reset");
-		if (retval < 0) {
-			dev_warn(dev, "Failed to set reset pin\n");
-			return retval;
-		}
-	}
+//	sensor->rst_gpio = of_get_named_gpio(dev->of_node, "rst-gpios", 0);
+//	if (!gpio_is_valid(sensor->rst_gpio))
+//		dev_warn(dev, "No sensor reset pin available");
+//	else {
+//		retval = devm_gpio_request_one(dev, sensor->rst_gpio,
+//				GPIOF_OUT_INIT_HIGH, "ov5640_mipi_reset");
+//		if (retval < 0) {
+//			dev_warn(dev, "Failed to set reset pin\n");
+//			return retval;
+//		}
+//	}
 
 
 	sensor->sensor_clk = devm_clk_get(dev, "csi_mclk");
@@ -1744,15 +1746,15 @@ static int ov5640_probe(struct i2c_client *client,
 		/* assuming clock enabled by default */
 		sensor->sensor_clk = NULL;
 		dev_err(dev, "clock-frequency missing or invalid\n");
-		return PTR_ERR(sensor->sensor_clk);
-	}
+//		return PTR_ERR(sensor->sensor_clk);
+	} else {dev_info(dev, "%s - csi_mclk clock-frequency defined\n", __func__);}
 
 	retval = of_property_read_u32(dev->of_node, "mclk",
 					&(sensor->mclk));
 	if (retval) {
 		dev_err(dev, "mclk missing or invalid\n");
 		return retval;
-	}
+	} else {dev_info(dev, "%s - mclk found\n", __func__);}
 
 	if (sensor->mclk == OV5640_XCLK_20MHZ)
 		ov5640_adjust_setting_20mhz();
@@ -1762,7 +1764,7 @@ static int ov5640_probe(struct i2c_client *client,
 	if (retval) {
 		dev_err(dev, "mclk_source missing or invalid\n");
 		return retval;
-	}
+	} else {dev_info(dev, "%s - mclk found\n", __func__);}
 
 	retval = of_property_read_u32(dev->of_node, "csi_id",
 					&(sensor->csi));
@@ -1793,8 +1795,10 @@ static int ov5640_probe(struct i2c_client *client,
 		retval = ov5640_update_slave_id(sensor);
 	}
 	mutex_unlock(&ov5640_mutex);
+
 	if (retval < 0) {
 		clk_disable_unprepare(sensor->sensor_clk);
+	printk("%s clk_disable_unprepare FAILED!, exit driver.\n", __func__);
 		return -ENODEV;
 	}
 
@@ -1806,6 +1810,7 @@ static int ov5640_probe(struct i2c_client *client,
 		clk_disable_unprepare(sensor->sensor_clk);
 		return -ENODEV;
 	}
+
 	retval = ov5640_read_reg(sensor, OV5640_CHIP_ID_LOW_BYTE, &chip_id_low);
 	if (retval < 0 || chip_id_low != 0x40) {
 		dev_warn(dev, "Camera is not found\n");
@@ -1821,18 +1826,24 @@ static int ov5640_probe(struct i2c_client *client,
 		clk_disable_unprepare(sensor->sensor_clk);
 		dev_warn(dev, "Camera init failed\n");
 		ov5640_power_down(sensor, 1);
+	printk("%s init_device FAILED!, exit driver.\n", __func__);
 		return retval;
 	}
 
 	v4l2_i2c_subdev_init(&sensor->subdev, client, &ov5640_subdev_ops);
+dev_info(dev, "%s: v4l2_i2c_subdev_init done\n", __func__);
 
 	sensor->subdev.grp_id = 678;
 	retval = v4l2_async_register_subdev(&sensor->subdev);
-	if (retval < 0)
+	if (retval < 0){
 		dev_err(&client->dev, "Async register failed, ret=%d\n",
 			retval);
+			} else {
+		dev_info(dev, "%s: v4l2_async_register_subdev done\n", __func__);
+			};
 
 	OV5640_stream_off(sensor);
+
 	dev_info(dev, "Camera is found\n");
 	return retval;
 }
diff --git a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
index dfc53d11053f..edb62be13845 100644
--- a/drivers/media/v4l2-core/v4l2-fwnode.c
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c
@@ -141,6 +141,8 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 	unsigned int i;
 	u32 v;
 	int rval;
+	
+printk("%s - start \n", __func__);
 
 	if (bus_type == V4L2_MBUS_CSI2_DPHY ||
 	    bus_type == V4L2_MBUS_CSI2_CPHY) {
@@ -160,7 +162,7 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 		}
 
 		if (use_default_lane_mapping)
-			pr_debug("no lane mapping given, using defaults\n");
+			printk("no lane mapping given, using defaults\n");
 	}
 
 	rval = fwnode_property_count_u32(fwnode, "data-lanes");
@@ -173,7 +175,7 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 
 		have_data_lanes = true;
 		if (use_default_lane_mapping) {
-			pr_debug("data-lanes property exists; disabling default mapping\n");
+			printk("data-lanes property exists; disabling default mapping\n");
 			use_default_lane_mapping = false;
 		}
 	}
@@ -181,20 +183,20 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 	for (i = 0; i < num_data_lanes; i++) {
 		if (lanes_used & BIT(array[i])) {
 			if (have_data_lanes || !use_default_lane_mapping)
-				pr_warn("duplicated lane %u in data-lanes, using defaults\n",
+				printk("duplicated lane %u in data-lanes, using defaults\n",
 					array[i]);
 			use_default_lane_mapping = true;
 		}
 		lanes_used |= BIT(array[i]);
 
 		if (have_data_lanes)
-			pr_debug("lane %u position %u\n", i, array[i]);
+			printk("lane %u position %u\n", i, array[i]);
 	}
 
 	rval = fwnode_property_count_u32(fwnode, "lane-polarities");
 	if (rval > 0) {
 		if (rval != 1 + num_data_lanes /* clock+data */) {
-			pr_warn("invalid number of lane-polarities entries (need %u, got %u)\n",
+			printk("invalid number of lane-polarities entries (need %u, got %u)\n",
 				1 + num_data_lanes, rval);
 			return -EINVAL;
 		}
@@ -204,20 +206,20 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 
 	if (!fwnode_property_read_u32(fwnode, "clock-lanes", &v)) {
 		clock_lane = v;
-		pr_debug("clock lane position %u\n", v);
+		printk("clock lane position %u\n", v);
 		have_clk_lane = true;
 	}
 
 	if (have_clk_lane && lanes_used & BIT(clock_lane) &&
 	    !use_default_lane_mapping) {
-		pr_warn("duplicated lane %u in clock-lanes, using defaults\n",
+		printk("duplicated lane %u in clock-lanes, using defaults\n",
 			v);
 		use_default_lane_mapping = true;
 	}
 
 	if (fwnode_property_present(fwnode, "clock-noncontinuous")) {
 		flags |= V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK;
-		pr_debug("non-continuous clock\n");
+		printk("non-continuous clock\n");
 	} else {
 		flags |= V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
 	}
@@ -251,14 +253,16 @@ static int v4l2_fwnode_endpoint_parse_csi2_bus(struct fwnode_handle *fwnode,
 
 			for (i = 0; i < 1 + num_data_lanes; i++) {
 				bus->lane_polarities[i] = array[i];
-				pr_debug("lane %u polarity %sinverted",
+				printk("lane %u polarity %sinverted",
 					 i, array[i] ? "" : "not ");
 			}
 		} else {
-			pr_debug("no lane polarities defined, assuming not inverted\n");
+			printk("no lane polarities defined, assuming not inverted\n");
 		}
 	}
 
+printk("%s - end \n", __func__);
+
 	return 0;
 }
 
@@ -278,6 +282,9 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 	unsigned int flags = 0;
 	u32 v;
 
+printk("%s - \n", __func__);
+
+
 	if (bus_type == V4L2_MBUS_PARALLEL || bus_type == V4L2_MBUS_BT656)
 		flags = bus->flags;
 
@@ -286,7 +293,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_HSYNC_ACTIVE_LOW);
 		flags |= v ? V4L2_MBUS_HSYNC_ACTIVE_HIGH :
 			V4L2_MBUS_HSYNC_ACTIVE_LOW;
-		pr_debug("hsync-active %s\n", v ? "high" : "low");
+		printk("hsync-active %s\n", v ? "high" : "low");
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "vsync-active", &v)) {
@@ -294,7 +301,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_VSYNC_ACTIVE_LOW);
 		flags |= v ? V4L2_MBUS_VSYNC_ACTIVE_HIGH :
 			V4L2_MBUS_VSYNC_ACTIVE_LOW;
-		pr_debug("vsync-active %s\n", v ? "high" : "low");
+		printk("vsync-active %s\n", v ? "high" : "low");
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "field-even-active", &v)) {
@@ -302,7 +309,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_FIELD_EVEN_LOW);
 		flags |= v ? V4L2_MBUS_FIELD_EVEN_HIGH :
 			V4L2_MBUS_FIELD_EVEN_LOW;
-		pr_debug("field-even-active %s\n", v ? "high" : "low");
+		printk("field-even-active %s\n", v ? "high" : "low");
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "pclk-sample", &v)) {
@@ -310,7 +317,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_PCLK_SAMPLE_FALLING);
 		flags |= v ? V4L2_MBUS_PCLK_SAMPLE_RISING :
 			V4L2_MBUS_PCLK_SAMPLE_FALLING;
-		pr_debug("pclk-sample %s\n", v ? "high" : "low");
+		printk("pclk-sample %s\n", v ? "high" : "low");
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "data-active", &v)) {
@@ -318,11 +325,11 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_DATA_ACTIVE_LOW);
 		flags |= v ? V4L2_MBUS_DATA_ACTIVE_HIGH :
 			V4L2_MBUS_DATA_ACTIVE_LOW;
-		pr_debug("data-active %s\n", v ? "high" : "low");
+		printk("data-active %s\n", v ? "high" : "low");
 	}
 
 	if (fwnode_property_present(fwnode, "slave-mode")) {
-		pr_debug("slave mode\n");
+		printk("slave mode\n");
 		flags &= ~V4L2_MBUS_MASTER;
 		flags |= V4L2_MBUS_SLAVE;
 	} else {
@@ -332,12 +339,12 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 
 	if (!fwnode_property_read_u32(fwnode, "bus-width", &v)) {
 		bus->bus_width = v;
-		pr_debug("bus-width %u\n", v);
+		printk("bus-width %u\n", v);
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "data-shift", &v)) {
 		bus->data_shift = v;
-		pr_debug("data-shift %u\n", v);
+		printk("data-shift %u\n", v);
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "sync-on-green-active", &v)) {
@@ -345,7 +352,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW);
 		flags |= v ? V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH :
 			V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW;
-		pr_debug("sync-on-green-active %s\n", v ? "high" : "low");
+		printk("sync-on-green-active %s\n", v ? "high" : "low");
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "data-enable-active", &v)) {
@@ -353,7 +360,7 @@ v4l2_fwnode_endpoint_parse_parallel_bus(struct fwnode_handle *fwnode,
 			   V4L2_MBUS_DATA_ENABLE_LOW);
 		flags |= v ? V4L2_MBUS_DATA_ENABLE_HIGH :
 			V4L2_MBUS_DATA_ENABLE_LOW;
-		pr_debug("data-enable-active %s\n", v ? "high" : "low");
+		printk("data-enable-active %s\n", v ? "high" : "low");
 	}
 
 	switch (bus_type) {
@@ -383,24 +390,27 @@ v4l2_fwnode_endpoint_parse_csi1_bus(struct fwnode_handle *fwnode,
 	struct v4l2_fwnode_bus_mipi_csi1 *bus = &vep->bus.mipi_csi1;
 	u32 v;
 
+printk("%s - \n", __func__);
+
+
 	if (!fwnode_property_read_u32(fwnode, "clock-inv", &v)) {
 		bus->clock_inv = v;
-		pr_debug("clock-inv %u\n", v);
+		printk("clock-inv %u\n", v);
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "strobe", &v)) {
 		bus->strobe = v;
-		pr_debug("strobe %u\n", v);
+		printk("strobe %u\n", v);
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "data-lanes", &v)) {
 		bus->data_lane = v;
-		pr_debug("data-lanes %u\n", v);
+		printk("data-lanes %u\n", v);
 	}
 
 	if (!fwnode_property_read_u32(fwnode, "clock-lanes", &v)) {
 		bus->clock_lane = v;
-		pr_debug("clock-lanes %u\n", v);
+		printk("clock-lanes %u\n", v);
 	}
 
 	if (bus_type == V4L2_MBUS_CCP2)
@@ -416,13 +426,16 @@ static int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 	enum v4l2_mbus_type mbus_type;
 	int rval;
 
+printk("%s <<- start\n", __func__);
+
 	if (vep->bus_type == V4L2_MBUS_UNKNOWN) {
 		/* Zero fields from bus union to until the end */
 		memset(&vep->bus, 0,
 		       sizeof(*vep) - offsetof(typeof(*vep), bus));
+printk("%s - vep->bus_type == V4L2_MBUS_UNKNOWN\n", __func__);
 	}
 
-	pr_debug("===== begin parsing endpoint %pfw\n", fwnode);
+	printk("===== begin parsing endpoint %pfw\n", fwnode);
 
 	/*
 	 * Zero the fwnode graph endpoint memory in case we don't end up parsing
@@ -431,25 +444,27 @@ static int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 	memset(&vep->base, 0, sizeof(vep->base));
 
 	fwnode_property_read_u32(fwnode, "bus-type", &bus_type);
-	pr_debug("fwnode video bus type %s (%u), mbus type %s (%u)\n",
+	printk("@@@@@>>>>> fwnode video bus type %s (%u), mbus type %s (%u)\n",
 		 v4l2_fwnode_bus_type_to_string(bus_type), bus_type,
 		 v4l2_fwnode_mbus_type_to_string(vep->bus_type),
 		 vep->bus_type);
 	mbus_type = v4l2_fwnode_bus_type_to_mbus(bus_type);
+	
 	if (mbus_type == V4L2_MBUS_INVALID) {
-		pr_debug("unsupported bus type %u\n", bus_type);
+		printk("unsupported bus type %u\n", bus_type);
 		return -EINVAL;
 	}
 
 	if (vep->bus_type != V4L2_MBUS_UNKNOWN) {
 		if (mbus_type != V4L2_MBUS_UNKNOWN &&
 		    vep->bus_type != mbus_type) {
-			pr_debug("expecting bus type %s\n",
+			printk("ERROR - expecting bus type %s\n",
 				 v4l2_fwnode_mbus_type_to_string(vep->bus_type));
 			return -ENXIO;
 		}
 	} else {
 		vep->bus_type = mbus_type;
+		printk("%s - mbus_type=%d\n", __func__, mbus_type);
 	}
 
 	switch (vep->bus_type) {
@@ -463,7 +478,7 @@ static int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 			v4l2_fwnode_endpoint_parse_parallel_bus(fwnode, vep,
 								V4L2_MBUS_UNKNOWN);
 
-		pr_debug("assuming media bus type %s (%u)\n",
+		printk("assuming media bus type %s (%u)\n",
 			 v4l2_fwnode_mbus_type_to_string(vep->bus_type),
 			 vep->bus_type);
 
@@ -477,6 +492,7 @@ static int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 	case V4L2_MBUS_CSI2_CPHY:
 		rval = v4l2_fwnode_endpoint_parse_csi2_bus(fwnode, vep,
 							   vep->bus_type);
+	printk("%s: v4l2_fwnode_endpoint_parse_csi2_bus, vep->bus_type=%d, rval==0?%d \n", __func__, vep->bus_type, rval);
 		if (rval)
 			return rval;
 
@@ -488,12 +504,14 @@ static int __v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 
 		break;
 	default:
-		pr_warn("unsupported bus type %u\n", mbus_type);
+		printk("unsupported bus type %u\n", mbus_type);
 		return -EINVAL;
 	}
 
 	fwnode_graph_parse_endpoint(fwnode, &vep->base);
 
+printk("%s <<- end\n", __func__);
+
 	return 0;
 }
 
@@ -504,7 +522,7 @@ int v4l2_fwnode_endpoint_parse(struct fwnode_handle *fwnode,
 
 	ret = __v4l2_fwnode_endpoint_parse(fwnode, vep);
 
-	pr_debug("===== end parsing endpoint %pfw\n", fwnode);
+	printk("===== end parsing endpoint %pfw\n", fwnode);
 
 	return ret;
 }
@@ -551,11 +569,11 @@ int v4l2_fwnode_endpoint_alloc_parse(struct fwnode_handle *fwnode,
 		}
 
 		for (i = 0; i < vep->nr_of_link_frequencies; i++)
-			pr_debug("link-frequencies %u value %llu\n", i,
+			printk("link-frequencies %u value %llu\n", i,
 				 vep->link_frequencies[i]);
 	}
 
-	pr_debug("===== end parsing endpoint %pfw\n", fwnode);
+	printk("===== end parsing endpoint %pfw\n", fwnode);
 
 	return 0;
 }
@@ -813,6 +831,9 @@ v4l2_async_notifier_fwnode_parse_endpoint(struct device *dev,
 	struct v4l2_async_subdev *asd;
 	int ret;
 
+printk("%s - \n", __func__);
+
+
 	asd = kzalloc(asd_struct_size, GFP_KERNEL);
 	if (!asd)
 		return -ENOMEM;
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 9121f044e86c..74976e839bbc 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1870,6 +1870,7 @@ static int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,
 static int v4l_streamon(const struct v4l2_ioctl_ops *ops,
 				struct file *file, void *fh, void *arg)
 {
+printk("%s\n", __func__);
 	return ops->vidioc_streamon(file, fh, *(unsigned int *)arg);
 }
 
diff --git a/drivers/mxc/mipi/mxc_mipi_csi2.c b/drivers/mxc/mipi/mxc_mipi_csi2.c
index 62b77a117a68..f163b3c3ff7b 100644
--- a/drivers/mxc/mipi/mxc_mipi_csi2.c
+++ b/drivers/mxc/mipi/mxc_mipi_csi2.c
@@ -371,6 +371,8 @@ static int mipi_csi2_probe(struct platform_device *pdev)
 	u32 mipi_csi2_dphy_ver;
 	int ret;
 
+dev_info(&pdev->dev, "%s - start\n", __func__);
+
 	gmipi_csi2 = kmalloc(sizeof(struct mipi_csi2_info), GFP_KERNEL);
 	if (!gmipi_csi2) {
 		ret = -ENOMEM;
diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index ae736a8b76ca..9415e77f3a92 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -122,9 +122,14 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 	}, {
-		.name		= "YUV32 (X-Y-U-V)",
-		.fourcc		= V4L2_PIX_FMT_YUV32,
-		.depth		= { 32 },
+//HH		.name		= "YUV32 (X-Y-U-V)",
+//HH		.fourcc		= V4L2_PIX_FMT_YUV32,
+//HH		.depth		= { 32 },
+//HH		.memplanes	= 1,
+//HH		.colplanes	= 1,
+		.name		= "YUV 4:2:2",
+		.fourcc		= V4L2_PIX_FMT_UYVY,
+		.depth		= { 16 },
 		.memplanes	= 1,
 		.colplanes	= 1,
 	}
diff --git a/drivers/staging/media/imx/imx8-isi-core.c b/drivers/staging/media/imx/imx8-isi-core.c
index 37d20f1d9c3c..1b07c5e3497b 100644
--- a/drivers/staging/media/imx/imx8-isi-core.c
+++ b/drivers/staging/media/imx/imx8-isi-core.c
@@ -40,9 +40,15 @@ static irqreturn_t mxc_isi_irq_handler(int irq, void *priv)
 	unsigned long flags;
 	u32 status;
 
+//printk(">> %s Is Streaming? = %x\n",__func__, mxc_isi->is_streaming);
+
 	spin_lock_irqsave(&mxc_isi->slock, flags);
 
 	status = mxc_isi_get_irq_status(mxc_isi);
+	
+//dev_info(&mxc_isi->pdev->dev, ">> %s: mxc_isi_get_irq_status(mxc_isi) = 0x%x\n", __func__, status);
+//dev_info(&mxc_isi->pdev->dev, ">> %s:  = 0x%x\n", __func__, mxc_isi->regs);
+
 	mxc_isi->status = status;
 	mxc_isi_clean_irq_status(mxc_isi, status);
 
@@ -674,6 +680,7 @@ static int mxc_isi_probe(struct platform_device *pdev)
 	const struct of_device_id *of_id;
 	int ret = 0;
 
+dev_info(dev, "%s - probe start\n", __func__);
 
 	mxc_isi = devm_kzalloc(dev, sizeof(*mxc_isi), GFP_KERNEL);
 	if (!mxc_isi)
diff --git a/drivers/staging/media/imx/imx8-isi-m2m.c b/drivers/staging/media/imx/imx8-isi-m2m.c
index 1e2071ec073b..a8eb97adabfd 100644
--- a/drivers/staging/media/imx/imx8-isi-m2m.c
+++ b/drivers/staging/media/imx/imx8-isi-m2m.c
@@ -1235,6 +1235,8 @@ static int isi_m2m_probe(struct platform_device *pdev)
 	struct video_device *vdev;
 	int ret = -ENOMEM;
 
+dev_info(&pdev->dev, "%s - probe start\n", __func__);
+
 	isi_m2m = devm_kzalloc(&pdev->dev, sizeof(*isi_m2m), GFP_KERNEL);
 	if (!isi_m2m)
 		return -ENOMEM;
diff --git a/drivers/staging/media/imx/imx8-media-dev.c b/drivers/staging/media/imx/imx8-media-dev.c
index b3e3168d5bf4..fd7ec0a56508 100644
--- a/drivers/staging/media/imx/imx8-media-dev.c
+++ b/drivers/staging/media/imx/imx8-media-dev.c
@@ -888,24 +888,28 @@ static int mxc_md_register_platform_entity(struct mxc_md *mxc_md,
 		if (!isi)
 			return -ENODEV;
 		ret = register_isi_entity(mxc_md, isi);
+printk("%s IDX_ISI\n", __func__);
 		break;
 	case IDX_MIPI_CSI2:
 		mipi_csi2 = mxc_md_parse_csi_entity(mxc_md, node);
 		if (!mipi_csi2)
 			return -ENODEV;
 		ret = register_mipi_csi2_entity(mxc_md, mipi_csi2);
+printk("%s IDX_MIPI_CSI2\n", __func__);
 		break;
 	case IDX_PARALLEL_CSI:
 		pcsidev = mxc_md_parse_pcsi_entity(mxc_md, node);
 		if (!pcsidev)
 			return -ENODEV;
 		ret = register_parallel_csi_entity(mxc_md, pcsidev);
+printk("%s IDX_PARALLEL_CSI\n", __func__);
 		break;
 	case IDX_HDMI_RX:
 		hdmi_rx = mxc_md_parse_hdmi_rx_entity(mxc_md, node);
 		if (!hdmi_rx)
 			return -ENODEV;
 		ret = register_hdmi_rx_entity(mxc_md, hdmi_rx);
+printk("%s IDX_HDMI_RX\n", __func__);
 		break;
 	default:
 		dev_err(dev, "Invalid platform entity (%d)", plat_entity);
@@ -1048,6 +1052,8 @@ static int mxc_md_probe(struct platform_device *pdev)
 	if (!mxc_md)
 		return -ENOMEM;
 
+dev_info(dev, "%s => start\n", __func__);
+
 	mxc_md->pdev = pdev;
 	platform_set_drvdata(pdev, mxc_md);
 
@@ -1071,16 +1077,21 @@ static int mxc_md_probe(struct platform_device *pdev)
 	if (ret < 0) {
 		v4l2_err(v4l2_dev, "Failed to register v4l2_device (%d)\n", ret);
 		goto clean_md;
+	} 
+	else { dev_info(dev, "%s => v4l2_device_register(ed)\n", __func__);
 	}
 
 	v4l2_async_notifier_init(&mxc_md->subdev_notifier);
 	ret = mxc_md_register_platform_entities(mxc_md, dev->of_node);
-	if (ret < 0)
+	if (ret < 0){
 		goto clean_v4l2;
+	} else { dev_info(dev, "%s => mxc_md_register_platform_entities - done\n",__func__);}
 
 	ret = register_sensor_entities(mxc_md);
-	if (ret < 0)
+	if (ret < 0){
 		goto clean_ents;
+		} else {
+		dev_info(dev, "%s => mxc_md_register_platform_entities - done\n",__func__);}
 
 	if (mxc_md->num_sensors > 0) {
 		mxc_md->subdev_notifier.ops = &sd_async_notifier_ops;
@@ -1092,7 +1103,8 @@ static int mxc_md_probe(struct platform_device *pdev)
 		if (ret < 0) {
 			dev_warn(&mxc_md->pdev->dev, "Sensor register failed\n");
 			return ret;
-		}
+		}else {
+		dev_info(&mxc_md->pdev->dev, "%s => v4l2_async_notifier_register - done\n",__func__); }
 
 		if (!mxc_md->link_status) {
 			if (mxc_md->valid_num_sensors > 0) {
diff --git a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
index 6df8d9b7b7dc..4e8728baa895 100644
--- a/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
+++ b/drivers/staging/media/imx/imx8-mipi-csi2-sam.c
@@ -116,6 +116,7 @@
 
 /* CSIS Interrupt source */
 #define MIPI_CSIS_INTSRC			0x14
+#define MIPI_CSIS_INTSRC_1			0x1C
 #define MIPI_CSIS_INTSRC_EVEN_BEFORE		(1 << 31)
 #define MIPI_CSIS_INTSRC_EVEN_AFTER		(1 << 30)
 #define MIPI_CSIS_INTSRC_EVEN			(0x3 << 30)
@@ -550,6 +551,7 @@ static void dump_csis_regs(struct csi_state *state, const char *label)
 	for (i = 0; i < ARRAY_SIZE(registers); i++) {
 		u32 cfg = mipi_csis_read(state, registers[i].offset);
 		v4l2_dbg(2, debug, &state->sd, "%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
+printk("%20s[%x]: 0x%.8x\n", registers[i].name, registers[i].offset, cfg);
 	}
 }
 
@@ -657,14 +659,16 @@ static void mipi_csis_clean_irq(struct csi_state *state)
 static void mipi_csis_enable_interrupts(struct csi_state *state, bool on)
 {
 	u32 val;
-
+printk("%s -> %d\n", __func__, on);
 	mipi_csis_clean_irq(state);
 
 	val = mipi_csis_read(state, MIPI_CSIS_INTMSK);
 	if (on)
 		val |= 0x0FFFFF1F;
-	else
+	else{
 		val &= ~0x0FFFFF1F;
+printk("FRAME_COUNT= %u\n", mipi_csis_read(state, MIPI_CSIS_FRAME_COUNTER_CH0));
+		}
 	mipi_csis_write(state, MIPI_CSIS_INTMSK, val);
 }
 
@@ -1056,6 +1060,9 @@ static void mipi_csis_log_counters(struct csi_state *state, bool non_errors)
 			v4l2_info(&state->sd, "%s events: %d\n",
 				  state->events[i].name,
 				  state->events[i].counter);
+	printk("%s events: %d\n",
+				  state->events[i].name,
+				  state->events[i].counter);
 	}
 	spin_unlock_irqrestore(&state->slock, flags);
 }
@@ -1095,6 +1102,7 @@ static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
 
 	v4l2_dbg(1, debug, mipi_sd, "%s: %d, state: 0x%x\n",
 		 __func__, enable, state->flags);
+	printk("%s: %d, state: 0x%x\n", __func__, enable, state->flags);
 
 	if (enable) {
 		pm_runtime_get_sync(state->dev);
@@ -1104,7 +1112,7 @@ static int mipi_csis_s_stream(struct v4l2_subdev *mipi_sd, int enable)
 		dump_gasket_regs(state, __func__);
 	} else {
 		mipi_csis_stop_stream(state);
-		if (debug > 0)
+	//	if (debug > 0)
 			mipi_csis_log_counters(state, true);
 		pm_runtime_put(state->dev);
 	}
@@ -1123,6 +1131,8 @@ static int mipi_csis_set_fmt(struct v4l2_subdev *mipi_sd,
 	struct v4l2_subdev *sen_sd;
 	int ret;
 
+printk("%s ->> mf->code = 0x%4x\n", __func__, mf->code);
+
 	/* Get remote source pad */
 	source_pad = csis_get_remote_sensor_pad(state);
 	if (!source_pad) {
@@ -1138,7 +1148,9 @@ static int mipi_csis_set_fmt(struct v4l2_subdev *mipi_sd,
 	}
 
 	format->pad = source_pad->index;
-	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	mf->code = MEDIA_BUS_FMT_UYVY8_2X8;	//0x2006
+//	mf->code = MEDIA_BUS_FMT_YUYV8_2X8;	//0x2008
+
 	ret = v4l2_subdev_call(sen_sd, pad, set_fmt, NULL, format);
 	if (ret < 0) {
 		v4l2_err(&state->sd, "%s, set sensor format fail\n", __func__);
@@ -1323,6 +1335,8 @@ static int csis_s_fmt(struct v4l2_subdev *sd, struct csi_sam_format *fmt)
 	if (csis_format == NULL)
 		return -EINVAL;
 
+printk("%s - csis_format: .code=%d, .fmt_reg=%d, .data_alignment=%d\n", __func__, csis_format->code, csis_format->fmt_reg, csis_format->data_alignment);
+
 	state->csis_fmt = csis_format;
 	state->format.width = fmt->width;
 	state->format.height = fmt->height;
@@ -1445,9 +1459,12 @@ static irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)
 	struct csis_pktbuf *pktbuf = &state->pkt_buf;
 	unsigned long flags;
 	u32 status;
+	
 
 	status = mipi_csis_read(state, MIPI_CSIS_INTSRC);
 
+printk("%s - MIPI_CSIS_INTSRC = 0x%08x\n",__func__, status);
+
 	spin_lock_irqsave(&state->slock, flags);
 	if ((status & MIPI_CSIS_INTSRC_NON_IMAGE_DATA) && pktbuf->data) {
 		u32 offset;
@@ -1826,6 +1843,8 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	const struct of_device_id *of_id;
 	int ret = -ENOMEM;
 
+dev_info(dev,"%s - start\n", __func__);
+
 	state = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);
 	if (!state)
 		return -ENOMEM;
diff --git a/drivers/staging/media/imx/imx8-parallel-csi.c b/drivers/staging/media/imx/imx8-parallel-csi.c
index 408082a29192..571c585210a4 100644
--- a/drivers/staging/media/imx/imx8-parallel-csi.c
+++ b/drivers/staging/media/imx/imx8-parallel-csi.c
@@ -705,6 +705,8 @@ static int mxc_parallel_csi_probe(struct platform_device *pdev)
 	struct mxc_parallel_csi_dev *pcsidev;
 	int ret;
 
+dev_info(dev,"%s - start\n", __func__);
+
 	pcsidev = devm_kzalloc(dev, sizeof(*pcsidev), GFP_KERNEL);
 	if (!pcsidev)
 		return -ENOMEM;
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 152a47a3f0cf..ab16bbc36a12 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -948,9 +948,59 @@ void phy_check_downshift(struct phy_device *phydev);
  * because the bus read/write functions may wait for an interrupt
  * to conclude the operation.
  */
+
+//static int result_reg_0x0A = 0x0000;
+
 static inline int phy_read(struct phy_device *phydev, u32 regnum)
 {
-	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
+	int result;
+	int result_;
+
+	result_=mdiobus_read(phydev->mdio.bus, phydev->mdio.addr, regnum);
+/*
+	if((phydev->phy_id==0x221642) | (phydev->phy_id==0x221622)){
+		//
+		result=result_;
+		//
+		if((regnum==0x0A) & (result_reg_0x0A==0x0006)){
+			result_reg_0x0A = 0x0006;
+			result=0x7800;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0005)){
+			result_reg_0x0A = 0x0006;
+			result=0x7800;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0004)){
+			result_reg_0x0A = 0x0005;
+			result=0x7800;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0003)){
+			result_reg_0x0A = 0x0004;
+			result=0x0800;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0002)){
+			result_reg_0x0A = 0x0003;
+			result=0x0800;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0001)){
+			result_reg_0x0A = 0x0002;
+			result=0x0000;
+		}
+		if((regnum==0x0A) & (result_reg_0x0A==0x0000)){
+			result_reg_0x0A = 0x0001;
+			result=0x0000;
+		}
+		//
+		if((regnum==0x05) & (result_reg_0x0A==0x7800)){
+			result=0xc5e1;		
+		}
+	} else result=result_;
+*/
+
+	result=result_;
+	printk("%s -> phy_id:0x%02x reg:0x%02x result_=0x%04x result=0x%04x\n",
+	__func__, phydev->phy_id, regnum, result_, result);
+	return result;
 }
 
 #define phy_read_poll_timeout(phydev, regnum, val, cond, sleep_us, \
diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 4c881f5d9080..49cc6111d956 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -3529,6 +3529,7 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event,
 
 			if (!addrconf_link_ready(dev)) {
 				/* device is not ready yet. */
+pr_info("ADDRCONF(NETDEV_CHANGE): %s: link is not ready\n", dev->name);
 				pr_debug("ADDRCONF(NETDEV_UP): %s: link is not ready\n",
 					 dev->name);
 				break;
@@ -3544,6 +3545,7 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event,
 		} else if (event == NETDEV_CHANGE) {
 			if (!addrconf_link_ready(dev)) {
 				/* device is still not ready. */
+pr_info("ADDRCONF(NETDEV_CHANGE): %s: device is still not ready\n", dev->name);
 				rt6_sync_down_dev(dev, event);
 				break;
 			}
-- 
2.25.1

